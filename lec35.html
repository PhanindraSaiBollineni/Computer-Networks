<html>

<!-- Mirrored from www.cse.iitk.ac.in/users/dheeraj/cs425/lec35.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 17 Sep 2022 16:16:51 GMT -->
<head>
<title>
 Computer Networks : Lecture 35
</title>
</head>
<body>
<a NAME="top"></A>
<body text = "BLACK" BGCOLOR="#ffffff">
<center>
<h1>Computer Networks </h1>
</center>

<A HREF="lec34.html">Prev</a>&nbsp;|
<A HREF="lec36.html">Next</A>&nbsp;|
<A HREF="index-2.html">Index</A>&nbsp;
<HR COLOR=black></HR>

<CENTER><h2>Network Security(Contd...)</h2></center>
<h3>Key Distribution Centre(Recap.)</h3>

There is a central trusted node called the Key Distribution Center ( KDC 
  ). Every node has a key which is shared between it and the KDC. Since no one 
  else knows node A's secret key K<sub>A</sub>, KDC is sure that the message it 
  received has come from A. When A wants to communicate with B it could do two 
  things:
<ol>
  <li>A sends a message encrypted in it's key K<sub>A</sub> to the KDC. The 
  KDC then sends a common key K<sub>S</sub> to both A and B encrypted in their 
  respective keys K<sub>A </sub>and<sub> </sub>K<sub>B</sub>. A and B can 
  communicate safely using this key.
  <li>Otherwise&nbsp; A sends a key K<sub>S</sub> to KDC saying that it wants 
  to talk to B encrypted in the key K<sub>A.</sub> KDC send a message to B 
  saying that A wants to communicate with you using K<sub>S.</sub>
</ol>

There is a problem with this implementation. It is prone to <b>replay attack</b>. 
The messages are in encrypted form and hence would not make sense to an intruder 
but they may be replayed to the listener again and again with the listener 
believing that the messages are from the correct source. When A send a message K<sub>A</sub>(M), 
C can send the same message to B by using the IP address of A. A solution to be 
used is to use the key only once. If B sends the first message K<sub>A</sub>(A,K<sub>S</sub>) 
also along with K(s,M), then again we may have trouble. In case this happens, B 
should accept packets only with higher sequence numbers. <p>
To prevent this, we can use:
<ul>
<li><b>Timestamps </b>which however don't generally work because of the offset 
in time between machines. Synchronization over the network becomes a problem.
<li><b>Nonce numbers </b>which are like ticket numbers. B accepts a message 
only if it has not seen this nonce number before. </li>
</ul>
<p>In general, 2-way handshakes are always prone to attacks. So we now look at 
an another protocol.</p>
<h3>Needham-Schroeder Authentication Protocol</h3>
<p>This is like a bug-fix to the KDC scheme to eliminate replay attacks. A 
  3-way handshake (using nonce numbers) very similar to the ubiquitous TCP 3-way 
  handshake is used between communicating parties. A sends a random number R<sub>A</sub> 
  to KDC. KDC send back a ticket to A which has the common key to be used.</p>

  <dd>&nbsp;</dd>
  <dd>
  <p align="center">
  <img border="0" src="fig.lec35/31-needham.gif" width="530" height="433"></dd>

<div align="center">
  
    <div align="left">
      R<sub>A</sub>, R<sub>B</sub><b> </b>and R<sub>A2</sub><b> </b>are 
      nonce numbers. R<sub>A</sub><b> </b>is used by A to communicate with the 
      KDC. On getting the appropriate reply from the KDC, A starts communicating 
      with B, whence another nonce number R<sub>A2</sub><b> </b>is used. The 
      first three messages tell B that the message has come from KDC and it has 
      authenticated A.&nbsp; The second last message authenticates B. The reply 
      from B contains R<sub>B</sub>,<b> </b>which is a nonce number generated by 
      B. The last message authenticates A. The last two messages also remove the 
      possibility of replay attack. 
    </div>
  
</div>
<p>  However, the problem with this scheme is that if somehow an 
  intruder gets to know the key&nbsp; K<sub>S </sub>( maybe a year later ), then 
  he can replay the entire thing ( provided he had stored the packets ). One 
  possible solution can be that the ticket contains a time stamp. We could also 
  put a condition that A and B should change the key every month or so. To 
  improve upon the protocol, B should also involve KDC for authentication. We 
  look at one possible improvement here. which is a different protocol.</div>

<h3>Otway-Rees Key Exchange Protocol </h3>
Here a connection is initiated first. This is followed by key generation. 
This ensures greater security. B sends the message sent by A to the KDC and the 
KDC verifies that A, B, R in the two messages are same and R<sub>A</sub> and R<sub>B</sub> 
have not been used for some time now. It then sends a common key to both A and 
B.</p>
<p align="center">
<img border="0" src="fig.lec35/31-otrees.gif" width="530" height="433"></p>
<p>In real life all protocols will have time-stamps. This is because we cannot 
remember all random numbers generated in the past. We ignore packets with higher 
time stamps than some limit. So we only need to remember nonces for this limit. 
Looking at these protocols, we can say that designing of protocols is more of an 
art than science. If there is so much problem in agreeing on a key then should 
we not use the same key for a long time. The key can be manually typed using a 
telephone or sent through some other media.</p>

<h3>Challenge - Response Protocol</h3>
<p>Suppose nodes A and B have a shared key K<sub>AB</sub> which was somehow 
pre-decided between them. Can we have a secure communication between A and B ? 
We must have some kind of a three way handshake to avoid replay attack So, we 
need to have some interaction before we start sending the data. A <i>challenges</i> 
B by sending it a random number R<sub>A </sub>and expects an encrypted reply 
using the pre-decided key K<sub>AB</sub>. B then&nbsp; <i>challenge</i>s A by 
sending it a random number R<sub>B </sub>and expects an encrypted reply using 
the pre-decided key K<sub>AB.</sub></p>
<center>
<table NOSAVE>
  <tr>
    <td>&nbsp;</td>
    <td>A</td>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    B</td>
  </tr>
  <tr NOSAVE>
    <td>1.</td>
    <td NOSAVE>A, R<sub>A</sub>-------------&gt;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>2.</td>
    <td align="right">&nbsp;</td>
    <td align="right">&lt;--------K<sub>AB</sub>(R<sub>A</sub>), R<sub>B</sub></td>
  </tr>
  <tr>
    <td>3.</td>
    <td>K<sub>AB</sub>(R<sub>B</sub>)----------&gt;</td>
    <td>&nbsp;</td>
  </tr>
</table>
</center>

<p>Unfortunately this scheme is so simple that this will not work.&nbsp; This 
protocol works on the assumption that there is a unique connection between A and 
B. If multiple connections are possible, then this protocol fails. In replay 
attack, we could repeat the message K<sub>AB</sub>(M) if we can somehow convince 
B that I am A. Here, a node C need not know the shared key to communicate 
with B. To identify itself as A, C just needs to send K<sub>AB</sub>(R<sub>B1</sub>) 
as the response to the challenge-value R<sub>B1</sub> given by B in the first 
connection. C can remarkably get this value through the second connection by 
asking B itself to provide the response to its own challenge. Thus, C can verify 
itself and start communicating freely with B. <br>
Thus, replay of messages becomes possible using the second connection. Any 
encryption desired, can be obtained by sending the value as R<sub>B2</sub> in 
the second connection, and obtaining its encrypted value from B itself. </p>
<center>
<table NOSAVE>
  <tr NOSAVE>
    <td NOSAVE>
    <table NOSAVE>
      <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>A</td>
        <td>B</td>
      </tr>
      <tr NOSAVE>
        <td>1<sup>st</sup> Connection:</td>
        <td>&nbsp;</td>
        <td NOSAVE>A, R<sub>A</sub>-------------&gt;</td>
        <td>&nbsp;</td>
      </tr>
      <tr NOSAVE>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td NOSAVE>&nbsp;</td>
        <td align="right">&lt;----------K<sub>AB</sub>(R<sub>A</sub>), R<sub>B1</sub></td>
      </tr>
      <tr>
        <td>2<sup>nd</sup> Connection:</td>
        <td>&nbsp;</td>
        <td>A, R<sub>B1</sub>------------&gt;</td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td align="right">&lt;--------- K<sub>AB</sub>(R<sub>B1</sub>), R<sub>B2</sub></td>
      </tr>
      <tr>
        <td>1<sup>st</sup> Connection:</td>
        <td>&nbsp;</td>
        <td>K<sub>AB</sub>(R<sub>B1</sub>)---------&gt;</td>
        <td>&nbsp;</td>
      </tr>
    </table>
    </td>
  </tr>
</table>
</center>

<p>Can we have a simple solution apart from time-stamp ? We could send K<sub>AB</sub>(R<sub>A,</sub>R<sub>B</sub>) 
in the second message instead of K<sub>AB</sub>(R<sub>A</sub>) and R<sub>A.
</sub>It may help if we keep two different keys for different directions. So we 
share two keys one from A to B and the other from B to A. If we use only one 
key, then we could use different number spaces ( like even and odd) for the two 
directions. Then A would not be able to send R<sub>B</sub>. So basically we are 
trying to look at the traffic in two directions as two different traffics. This 
particular type of attack is called <b>reflection attack</b>.</p>

<h3>5 - way handshake</h3>
We should tell the sender that the person who initiates the connection should 
authenticate himself first. So we look at another protocol. Here we are using a 
5-way handshake but it is secure. When we combine the messages, then we are 
changing the order of authentication which is leading to problems. Basically K<sub>AB</sub>(R<sub>B</sub>) 
should be sent before K<sub>AB</sub>(R<sub>A</sub>). If we have a node C in the middle, then C can 
pose as B and talk to A. So C can do replay attack by sending messages which it 
had started some time ago.</p>
<center>
<table NOSAVE>
  <tr NOSAVE>
    <td NOSAVE>&nbsp;</td>
    <td>A</td>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B</td>
  </tr>
  <tr NOSAVE>
    <td>1.</td>
    <td NOSAVE>A------------------&gt;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>2.</td>
    <td>&nbsp;</td>
    <td align="right">&lt;-----------------R<sub>B</sub></td>
  </tr>
  <tr NOSAVE>
    <td>3.</td>
    <td NOSAVE>K<sub>AB</sub>(R<sub>B</sub>)----------&gt;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>4.</td>
    <td>R<sub>A</sub>----------------&gt;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>5.</td>
    <td>&nbsp;</td>
    <td align="right">&lt;----------K<sub>AB</sub>(R<sub>A</sub>)</td>
  </tr>
</table>
</center><center>
<p><font size="-1">Fig: 5-way handshake in Challenge-Response Protoco</font>l</p>
</center>
On initiating a connection B challenges A by sending it a random number R<sub>B</sub> 
and expects an encrypted reply using the pre-decided key K<sub>AB. </sub>When A 
sends back K<sub>AB</sub>(R<sub>B</sub>), B becomes sure that it is talking to 
the correct A, since only A knows the shared key.
Now A challenges B by sending it a random number R<sub>A</sub>, and expects 
an encrypted reply using the pre-decided key K<sub>AB. </sub>When B sends back K<sub>AB</sub>(R<sub>A</sub>), 
A becomes sure that it is talking to the&nbsp; correct B, since only B knows the 
shared key.
<p>However in this case also, if we have a node C in the middle, then C can pose 
as B and talk to A. So C can do replay attack by sending messages which it had 
stored some time ago !!<br>



<hr COLOR=black>
<A HREF="#top">back to top</A><br>
<A HREF="lec34.html">Prev</A>|&nbsp<A HREF="lec36.html">Next </A>|
<A HREF="index-2.html">Index</A>
</P>
</BODY>

<!-- Mirrored from www.cse.iitk.ac.in/users/dheeraj/cs425/lec35.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 17 Sep 2022 16:16:52 GMT -->
</HTML>addressing. We could say that the network number is 21 bits ( for 8 class C networks ) or say that it is 24 bits and 7 numbers following that. For example : a.b.c.d / 21
